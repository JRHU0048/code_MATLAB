%% 蒙特卡洛模拟：内生性会造成回归系数的巨大误差
times = 300;  % 蒙特卡洛的次数
R = zeros(times,1);  % 构建300*1的0矩阵，用来储存扰动项u和x1的相关系数
K = zeros(times,1);  % 构建300*1的0矩阵，用来储存遗漏了x2之后，只用y对x1回归得到的回归系数
for i = 1: times
    n = 30;  % 样本数据量为n
    x1 = -10+rand(n,1)*20;   % x1在-10和10上均匀分布，大小为30*1
    u1 = normrnd(0,5,n,1) - rand(n,1);  % 随机生成一组随机数
    x2 = 0.3*x1 + u1;   % x2与x1的相关性不确定， 因为我们设定了x2要加上u1这个随机数
    % 这里的系数0.3是随便给的，可以更改。
    u = normrnd(0,1,n,1);  % 扰动项u服从标准正态分布
    y = 0.5 + 2 * x1 + 5 * x2 + u ;  % 构造y
    k = (n*sum(x1.*y)-sum(x1)*sum(y))/(n*sum(x1.*x1)-sum(x1)*sum(x1)); % y = k*x1+b 回归估计出来的k
    K(i) = k;
    u = 5 * x2 + u;  % 因为我们回归中忽略了5*x2，所以扰动项要加上5*x2
    r = corrcoef(x1,u);  % 2*2的相关系数矩阵
    R(i) = r(2,1);
end
plot(R,K,'*')
xlabel("x_1和u'的相关系数")
ylabel("k的估计值")

这段代码是一个蒙特卡洛模拟实验，用于研究在回归模型中忽略某个重要变量时的影响。
首先，通过设定 times 的值为300，表示需要进行300次模拟实验。然后创建了两个数组 R 和 K，分别用于存储扰动项 u 和变量 x1 的相关系数和回归系数 k 的估计值。
接下来，使用循环从1到 times，依次进行模拟实验。在每次实验中，设定样本数据量 n 为30，并从均匀分布生成 x1 在-10到10之间的随机数。通过设定一个随机数 u1，并将其加到 x1 中得到 x2。
然后，生成一个服从标准正态分布的扰动项 u，并构造回归模型 y = k*x1 + b，其中 k 的估计值通过最小二乘法计算得出。
在忽略变量 x2 并只用变量 x1 进行回归时，将扰动项 u 加上 5*x2，以模拟忽略了 x2 的情况。
通过 corrcoef(x1,u) 计算 x1 和调整后的扰动项 u 的相关系数，并将结果保存到数组 R 中。将回归系数 k 的估计值保存到数组 K 中。
最后，使用 plot(R,K,'*') 绘制散点图，横轴为 x1 和调整后的扰动项 u 的相关系数，纵轴为回归系数 k 的估计值。通过观察散点图，可以研究忽略了 x2 变量时回归估计值的偏差情况。

蒙特卡罗算法是一种基于随机采样的数值计算方法，它的主要思想是通过随机采样来估计某个问题的概率或数值。该算法最早由美国物理学家冯·诺依曼和斯坦尼斯拉夫·乌拉姆在20世纪40年代提出，名称源自于摩纳哥的蒙特卡罗市，这里以赌博游戏著名。
蒙特卡罗算法的应用非常广泛，如金融工程、计算机视觉、生物信息学等领域。对于那些难以用数学公式或解析方法求解的问题，蒙特卡罗算法通常是有效的解决方案。
蒙特卡罗算法的关键是构造可靠的随机样本集合。这个样本集合必须满足两个条件：一是每个样本必须是独立的；二是样本的分布必须与所求解问题相关。
在蒙特卡罗算法中，通过对样本进行计算，得到问题的一个估计值，这个估计值的精度取决于样本数量的大小。当样本数量越来越大时，估计值会逐渐趋近于真实值。因此，蒙特卡罗算法的计算精度可以随着样本数量的增加而提高。
总之，蒙特卡罗算法是一种基于随机采样的数值计算方法，它适用于很多难以用解析方法求解的问题，并且可以通过增加样本数量来提高计算精度。


用法示例：利用蒙特卡洛算法求解圆周率（写一个求解函数）
function estimated_pi = monte_carlo_pi(n)
    count = 0;  % 计数器，记录落在圆内的点的数量
    
    for i = 1:n
        x = rand() * 2 - 1;  % 在[-1, 1]范围内生成随机x坐标
        y = rand() * 2 - 1;  % 在[-1, 1]范围内生成随机y坐标
        
        if x^2 + y^2 <= 1  % 判断点是否落在单位圆内
            count = count + 1;
        end
    end
    
    pi = 4 * count / n;  % 根据落在圆内的点与总点数的比例计算出π的估计值
    estimated_pi = pi;
end

% 测试
num_samples = 1000000;
estimated_pi = monte_carlo_pi(num_samples);
fprintf('估计的π值为：%f\n', estimated_pi);
